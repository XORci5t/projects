import binascii
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

p = 298211241770542957242152607176537420651
# a = p - 1 corresponds to 'a = -1 mod p'
a = p - 1
G = (107989946880060598496111354154766727733,
     36482365930938266418306259893267327070)

def modinv(a, p):
    """Modular inverse via extended Euclidean algorithm."""
    lm, hm = 1, 0
    low, high = a % p, p
    while low > 1:
        ratio = high // low
        lm, low, hm, high = hm - lm * ratio, high - low * ratio, lm, low
    return lm % p


def ec_add(P, Q, a, p):
    """Add two points P and Q on the elliptic curve y^2 = x^3 + a*x + b over field F_p."""
    if P is None:
        return Q
    if Q is None:
        return P

    x1, y1 = P
    x2, y2 = Q

    if x1 == x2 and (y1 + y2) % p == 0:
        return None  # P + (-P) = infinity

    if x1 == x2 and y1 == y2:
        s = ((3 * x1 * x1 + a) * modinv(2 * y1, p)) % p
    else:
        s = ((y2 - y1) * modinv(x2 - x1, p)) % p

    x3 = (s * s - x1 - x2) % p
    y3 = (s * (x1 - x3) - y1) % p
    return (x3, y3)


def ec_scalar_mult(k, P, a, p):
    result = None
    addend = P
    while k:
        if k & 1:
            result = ec_add(result, addend, a, p)
        addend = ec_add(addend, addend, a, p)
        k >>= 1
    return result


def int_to_bytes(x):
    return x.to_bytes((x.bit_length() + 7) // 8 or 1, 'big')


def main():
    # Public keys from logs
    server_pub = (72947667249607227642932393260968830921,
                  261432642373021661017738970173175343657)
    client_pub = (291216048318375702409990419027018106946,
                  219380392381458352976435257541531938506)

    # 1. Find the subgroup order m by searching for k*G == infinity
    m = None
    for k in range(1, 5000):
        if ec_scalar_mult(k, G, a, p) is None:
            m = k
            break
    if m is None:
        raise RuntimeError("Failed to find subgroup order up to 5000")
    print(f"Subgroup order m = {m}")

    # 2. Brute-force the private key modulo m
    server_priv_mod = None
    for d in range(m):
        if ec_scalar_mult(d, G, a, p) == server_pub:
            server_priv_mod = d
            break
    if server_priv_mod is None:
        raise RuntimeError("Server private key not found in subgroup")
    print(f"Recovered server_priv_mod = {server_priv_mod}")

    # 3. Derive the shared secret point
    shared_point = ec_scalar_mult(server_priv_mod, client_pub, a, p)
    if shared_point is None:
        raise RuntimeError("Derived shared point is at infinity")
    shared_key = int_to_bytes(shared_point[0])
    print(f"Derived shared_key (hex) = {shared_key.hex()}\n")

    # 4. Decrypt intercepted messages
    cipher_texts = [
        "955e81123cceced7da5c9fe8c72633a4c971c5c96651f85b5d40f628a48c75f1",
        "1f2e0cdfa573b9c4218991336596509c275e9c8b3df4cbae57d820bf6535b117",
        "7c037f2d5ed214afefc4cf1c8a8773996d9fc5a8cf69c733e3f75a2b73c43861232d055fe4c76e850c859ebd1d59df14",
        "dc32a919810ff9369548077c0c6e68c1dad12c5c10cbba0a4eb2603b60a4dd47da3603e3c7b8cd561386fcd5031bed6a",
        "8217705cc9fbef141c613da12dd87885121d30ac9ebb656146fc1cd17f00d261"
    ]

    for idx, hex_blob in enumerate(cipher_texts, 1):
        data = binascii.unhexlify(hex_blob)
        iv, ct = data[:16], data[16:]
        cipher = AES.new(shared_key[:32], AES.MODE_CBC, iv)
        pt = unpad(cipher.decrypt(ct), AES.block_size)
        print(f"Message {idx}: {pt.decode()}")


if __name__ == "__main__":
    main()
